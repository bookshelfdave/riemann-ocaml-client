{"google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"A Riemann client for OCaml.","body":"riemann-ocaml-client\r\n====================\r\n\r\n© 2013 Dave Parfitt\r\n\r\nriemann-ocaml-client is a [Riemann](http://riemann.io) client for OCaml.\r\n\r\n##Dependencies\r\n\r\n* [ocamlfind](http://projects.camlcity.org/projects/findlib.html)\r\n* [Piqi](http://piqi.org/) \r\n* [Protobuffs](http://code.google.com/p/protobuf/)\r\n   * On OSX, `brew install protobuf` if you are using Homebrew\r\n* [OUnit](http://ounit.forge.ocamlcore.org/)\r\n\r\n## Building from source\r\n\r\n```\r\n./configure\r\nmake\r\nmake install\r\n```\r\n\r\n## Documentation\r\n\r\n\r\n### TCP Connections\r\n\r\n\r\nThe following functions allow you to communicate via TCP to Riemann:\r\n\r\n\r\n\tval riemann_connect_with_defaults : string -> int -> riemann_connection\r\n\t\t\r\n\tval riemann_connect : riemann_connection_options -> string -> int -> riemann_connection\r\n\r\n\tval riemann_disconnect : riemann_connection -> unit\r\n\r\nThe first string parameter of the connect functions is the IP/hostname, and the second parameter is the port # of Riemann.\r\n\r\n\r\n### UDP Sockets\r\n\r\nThe following function allows you to open a UDP socket to Riemann. Note the tuple return type.\r\n\r\n\tval riemann_udp_socket : string -> int -> Unix.file_descr * Unix.sockaddr\r\n\r\n\r\n### Generating Events\r\n\r\nSince most of the fields of the Riemann Event message are optional, you can use the `riemann_event` function to pass a list of desired parameters without manually populating the entire record. If you want more control of the Event record, you can simply instantiate a `Riemann_piqi.Event.t`. Note that ultimately, these event messages must be added to a `Msg` record to be passed to Riemann.\r\n\r\n```\r\ntype riemann_event =\r\n    Event_time of int64\r\n  | Event_state of string\r\n  | Event_service of string\r\n  | Event_host of string\r\n  | Event_description of string\r\n  | Event_tags of string list\r\n  | Event_ttl of float\r\n  | Event_metric_sint64 of int64\r\n  | Event_metric_f of float\r\n  | Event_metric_d of float\r\n\r\nval riemann_event : riemann_event list -> Riemann_piqi.Event.t\r\n```\r\n\r\n### Generating States\r\n\r\nSince most of the fields of the Riemann State message are optional, you can use the `riemann_state` function to pass a list of desired parameters without manually populating the entire record. If you want more control of the State record, you can simply instantiate a `Riemann_piqi.State.t`. Note that ultimately, these event messages must be added to a `Msg` record to be passed to Riemann.\r\n\r\n\r\n```\r\ntype riemann_state =\r\n    State_time of int64\r\n  | State_state of string\r\n  | State_service of string\r\n  | State_host of string\r\n  | State_description of string\r\n  | State_once of bool\r\n  | State_tags of string list\r\n  | State_ttl of float\r\n\r\n\r\nval riemann_state : riemann_state list -> Riemann_piqi.State.t\r\n```\r\n\r\n### Generating Queries\r\n\r\nSince the Riemann Query has only a single string parameter, the `riemann_query` returns a `Riemann_piqi.Msg.t` with the query populated instead of a `Riemann_piqi.Query.t`. Feel free to roll your own `Riemann_piqi.Query.t` if you need it.\r\n\r\n```\r\nval riemann_query : string -> Riemann_piqi.Msg.t\r\n```\r\n\r\n### Generating Protobuffs Messages w/ Events, States and Queries\r\n\r\nOnce you have a list of Events, list of States, or Query, you can build a protocol buffers message using the following convenience functions:\r\n\r\n\tval new_riemann_events_msg : Riemann_piqi.Riemann_piqi.event list -> Riemann_piqi.Msg.t\r\n\r\n\tval new_riemann_states_msg : Riemann_piqi.Riemann_piqi.state list -> Riemann_piqi.Msg.t\r\n\r\n\tval new_riemann_query_msg : string -> Riemann_piqi.Msg.t\r\n\r\n`Riemann_piqi.Msg.t` records can then be sent to Riemann using `send_msg_tcp` or `send_msg_udp`.\r\n\r\n*Note*: since your Query is probably already a `Riemann_piqi.Msg.t`, you probably won't find much use for `new_riemann_query_msg`.\r\n\r\n### Sending and Receiving Protobuffs Messages\r\n\r\n`Riemann_piqi.Msg.t` records can then be sent to Riemann using `send_msg_tcp` or `send_msg_udp`.\r\n\r\n\r\n\tval send_msg_tcp : riemann_connection -> Riemann_piqi.Msg.t -> Riemann_piqi.Msg.t\r\n\r\n\tval send_msg_udp : Unix.file_descr * Unix.sockaddr -> Riemann_piqi.Msg.t -> int\r\n\r\n\r\n## Examples\r\n\r\n#### Events\r\n\r\n```\r\n  let udp_socket = riemann_udp_socket ip port in\r\n  let event =\r\n    riemann_event [\r\n      Event_host \"www1\";\r\n      Event_service \"testservice\";\r\n      Event_metric_f 2.53;\r\n      Event_state \"critical\";\r\n      Event_description \"my description\";\r\n      Event_tags  [\"http\"] ] in\r\n  let event_msg = new_riemann_events_msg [event] in\r\n  let _ = send_msg_udp udp_socket event_msg in\r\n  \t()\r\n```\r\n\r\n#### States\r\n\r\n```\r\n  let udp_socket = riemann_udp_socket ip port in\r\n  let state =\r\n    riemann_state [\r\n      State_host \"www1\";\r\n      State_service \"testservice\";\r\n      State_state \"critical\";\r\n      State_description \"my description\";\r\n      State_tags  [\"http\"] ] in\r\n  let state_msg = new_riemann_states_msg [state] in\r\n  let _ = send_msg_udp udp_socket state_msg in\r\n    ()\r\n```\r\n\r\n#### Queries\r\n\r\n\r\n```\r\nlet conn = riemann_connect_with_defaults ip port in\r\nlet q = (\"service = \\\"testservice\\\"\") in\r\nlet msg = new_riemann_query_msg q in\r\nlet resp = send_msg_tcp conn msg in\r\nmatch resp.Msg.ok with\r\n\t| Some true -> (* your code here *)\r\n    | Some false -> (* your code here *)\r\n    | None -> (* your code here *)\r\n```\r\n\r\nand you'll probably want a `riemann_disconnect` in there somewhere as well.\r\n\r\n## Tests\r\n\r\nTo run the tests, you'll need to run `make test`, and then the `test.byte` executable against a running Riemann instance. To change the IP/Port that the tests connect to, you can use the following environment variables:\r\n\r\n\tRIEMANN_OCAML_TEST_IP\r\n\r\n\tRIEMANN_OCAML_TEST_PORT\r\n\r\n## TODO\r\n\r\n- LWT support if anyone asks about it\r\n- OPAM module once Piqi is released in OPAM\r\n\r\n## License & Copyright\r\n\r\nCopyright © 2013 Dave Parfitt\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at\r\n\r\n[http://www.apache.org/licenses/LICENSE-2.0](http://www.apache.org/licenses/LICENSE-2.0)\r\n\r\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\r\n\r\n","name":"Riemann-ocaml-client"}